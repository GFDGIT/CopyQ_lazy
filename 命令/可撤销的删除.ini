[Commands]
1\Name=撤销删除
1\Command="
    copyq:
    // true: update time_mime and tags_mime
    // false: keep tags, and use time from tags
    const update_item_time = true;

    const trash_tab = settings(\"trash_tab\");
    const tab_mime = \"application/x-copyq-user-tab\";
    const index_mime = \"application/x-copyq-user-index\";
    const time_mime = \"application/x-copyq-user-time\";
    const tags_mime = \"application/x-copyq-tags\";
    const now = dateString(\"yyyy-MM-dd hh:mm:ss\");
    const time_reg = /\\d{4}-\\d{2}-\\d{2} \\d{2}\\:\\d{2}\\:\\d{2}/;

    tab(trash_tab);
    if (length() == 0) {
        popup('Nothing to undo.');
        abort();
    }

    const trigger_tab = selectedTab();
    let remove_rows = []; // list to be remove, type: int array
    let target_index = [];
    let items = []; // list to be restore, type: item array
    let target_tab = [];

    // Triggered from the trash tab, only selected items are restored
    if (trigger_tab == trash_tab) {
        items = ItemSelection().current().items();
        remove_rows = selectedItems();
        target_tab = items.map(item => str(item[tab_mime]) || selectedTab());
        target_index = items.map((_, i) => i);    // items are always restored at the top of the tab
    } else {
        let item = getitem(0);
        let time = str(item[time_mime]);
        let i = 0;
        while (true) {
            target_tab.push(str(item[tab_mime]) || selectedTab());
            target_index.push(item[index_mime] || 0)
            remove_rows.push(i);
            items.push(item);

            item = getItem(++i)
            if (!time || time !== str(item[time_mime])) {
                break;
            }
        }
    }

    for (let i = items.length-1; i >=0; i--) {
        let item = items[i];

        delete item[tab_mime];
        delete item[index_mime];

        let old_tag = str(item[tags_mime]);
        let old_time = old_tag.match(time_reg);
        if (update_item_time && old_time) {
            item[time_mime] = now;
            item[tags_mime] = old_tag.replace(old_time, now);
        } else {
            item[time_mime] = old_time;
        }
        tab(target_tab[i]);
        insert(target_index[i], item);
    }

    show(target_tab[0]);
    tab(target_tab[0]);

    selectItems.apply(this, target_index);

    tab(trash_tab);
    remove.apply(this, remove_rows);"
1\InMenu=true
1\Icon=
1\Shortcut=ctrl+z
2\Name=删除至回收站
2\Command="
    const onItemsRemoved_ = global.onItemsRemoved
    global.onItemsRemoved = function () {
        const trash_tab = '回收站'
        const tab_mime = 'application/x-copyq-user-tab'
        const index_mime = 'application/x-copyq-user-index'
        const time_mime = 'application/x-copyq-user-time'

        const source_tab = selectedtab()
        const sel = ItemSelection().current()

        if (!settings('trash_tab')) 
            settings('trash_tab', trash_tab)

        tab(trash_tab)
        var available = config('maxitems') - count()
        if (sel.length > available) {
            popup('待删除条目过多，无法移至回收站。\\n请先清理回收站，或调大条目历史数量上限。', 3000)
        }
        if (source_tab == trash_tab) {
            serverLog(`Removing ${sel.length} items from ${source_tab}`)
        } else {
            serverLog(`Removing ${sel.length} items from ${source_tab} to ${trash_tab}`)
            const time = dateString('yyyy-MM-dd hh:mm:ss.zzz')

            const rows = sel.rows()
            let trashed = sel.items().map((item, i) => {
                item[tab_mime] = source_tab
                item[index_mime] = rows[i]
                item[time_mime] = time
                return item
            })

            tab(trash_tab)
            write(0, trashed)
            tab(source_tab)
        }
        onItemsRemoved_()
    }"
2\IsScript=true
2\Icon=
size=2